# Command-Line Interface Chess
#### Video Demo:  https://youtu.be/vit6YXHN6dw
#### Description: The C programming language is used to create the command-line chess game CLI Chess. This projects primary goal was to develop a fully functional chess game that operates entirely inside a terminal without the need for a graphical user interface. The emphasis is on clear structure intelligible code and game logic rather than graphics. The game is intended for two local players who alternately enter their moves via the command line. The program is in charge of all board updates rules and validations. Creating a clear modular code structure was one of the projects main objectives. Chess logic can quickly become complicated so it was crucial to avoid packing everything into a single big file. The project is divided into several source files with distinct roles as a result. This facilitates reading debugging and future expansion of the code in the event that new features are needed. the main file. c is the programs entry point and governs the games overall flow. At this point the game begins the board is set up and the main game loop begins. The program alternates between the two players requests input and determines whether the game should end or continue during this loop. principal. Chess logic is not present in the C file itself. Rather it primarily invokes functions that are implemented in different files. This design decision keeps the main file straightforward and concentrates solely on organizing the game rather than putting the rules into practice. The file game incorporates the majority of the real chess logic. (c). Every crucial function required to keep the game running is contained in this file. The board is set up pieces are moved moves are validated and the game state is updated after each turn. Additionally it prints the board to the terminal using ASCII art. It is much simpler to comprehend how the game operates internally because all chess-related functionality is contained in this file which keeps the logic in one central location. The chess header file. The interface between the various program components is defined by h. It includes function prototypes for every significant game function as well as the shared struct definitions between files. both principal. C and a game. To ensure that they utilize the same data structures and function signatures c includes this header file. By doing this errors that might arise from spreading definitions across several files are avoided. The use of ASCII art to display the chess board in this project is an obvious design choice. ASCII art is a logical choice and a great fit for the environment because the game is played from the command line. Additionally it eliminates the need for platform-specific graphics solutions or external libraries. Furthermore the ASCII style makes the board easy to read while playing and gives the game a traditional terminal appearance which I personally liked. Dividing the project into several files rather than writing everything in a single source file was another crucial design decision. Readability and maintainability were enhanced by this. A single file would easily become confusing as the number of functions increased. The project feels more like a real-world software project rather than a small experiment because of the structure that was selected which adheres to standard C programming practices. En passant is a chess rule that isnt used in this project. This is due to a technical limitation rather than a lack of knowledge of the rule. The necessary state tracking was not cleanly supported by the API used to control the board and moves. Because of this the relevant code was commented out and the feature was purposefully omitted. This choice was made in order to put a stable and comprehensible implementation ahead of full rule coverage. The project was developed with an API-oriented mindset despite its small size. Functions are written in a reusable manner with distinct responsibility divisions. This enables future game expansion such as the addition of an AI opponent the introduction of new chess rules or enhanced input validation. The game still has certain restrictions in its current version. In addition to the missing en passant rule some edge cases are not fully covered and the input handling could be strengthened. Nonetheless the game is completely playable and illustrates the fundamentals of chess in a command-line setting. Finally CLI Chess demonstrates that a sophisticated board game like chess can be implemented in C with just the terminal. The project strikes a good balance between functionality and simplicity thanks to its modular file structure clear interfaces and thoughtful design choices. It functions as a playable game and an educational project for C structured programming.